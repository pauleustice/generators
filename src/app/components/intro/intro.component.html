<div class="content" role="main">
  <h1>Intro to Generators</h1>

  <div class="card card--headed">
    <div class="header">Overview</div>
    <ul>
      <li>A hybrid between a regular function and an Iterable</li>
      <li>They pause and resume, and can keep track of internal state</li>
      <li>...which makes them great for async work. <code>async/await</code> is internally based on generators</li>
      <li>They yield multiple values across runs</li>
      <li>A generator cannot resume itself, that's done with <code>next()</code></li>
    </ul>
  </div>

  <div class="card card--headed">
    <div class="header">Key details</div>
    <ul>
      <li>Differentiated from normal functions using the asterisk syntax <code>function *myGenerator()</code> </li>
    </ul>

    <app-console>
      <pre><span class="comment">As a straight up function:</span></pre>
      <pre>function *myGenerator () {{ '{' }}</pre>
      <pre>  <span class="comment">// generator code here</span></pre>
      <pre>}</pre>
      <pre>

      </pre>
      <pre><span class="comment">Or in a class:</span></pre>
      <pre>class myClass {{ '{' }}</pre>
      <pre>  *myGenerator () {{ '{' }}</pre>
      <pre>    <span class="comment">// generator code here</span></pre>
      <pre>  }</pre>
      <pre>}</pre>
    </app-console>

    <ul>
      <li>When called, returns a reference to a Generator Object, upon which you call <code>next()</code></li>
      <li><code>next()</code> returns an object with the last yielded value (<code>value</code>) and whether it has completed (<code>done</code>)</li>
    </ul>

    <app-console>
      <pre>const foo = myGenerator();</pre>
      <pre>foo.next(); <span class="comment">// returns e.g. {{ '{' }} value: 1, done: false }</span></pre>
    </app-console>
  </div>
</div>
